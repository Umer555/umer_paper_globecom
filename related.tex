\section{Related Work}
\label{sec:related}

Although cloud service providers (CSP) allow data to be encrypted for security
purposes, encryption leads to two problems. First, searching for 
keywords within data encrypted using popular encryption algorithms is not
possible. Second, if you provide the CSP the decryption keys, 
you cannot prevent the CSP from accessing the confidential 
data.
Recent work has focused on solving these problems using a variety of techniques,
which we broadly classify into two categories.

\textbf{Using Trapdoor Encryption.}
Song et al. \cite{song} propose a symmetric key based
searchable scheme for encrypted data. Each keyword in the document is encrypted independently
using trapdoors. Their approach proposes ways to search encrypted data using 
both an
encrypted index as well as searching the original data itself. 
Goh et al.\cite{goh2003secure} propose encrypted search using bloom filters. They generate trapdoors
against all the keywords in a file and add them to a bloom filter stored
in the cloud. 
To search, a user computes the trapdoor for a keyword and sends it to the cloud
server. The cloud server checks the trapdoor in the bloom filter, and if
it exists, returns the corresponding file identifier. 
Boneh et al \cite{boneh}
present one of the earliest public key based encrypted search algorithm, 
enabling 
authorized users having 
the private key to search in the index. 
Yu et al. \cite{li} use
Hierarchical Predicate Encryption (HPE) for encrypted search. 
All of the above schemes support only
exact keyword matches and rely on pre-defined trapdoors.

Pal et al. \cite{saibal} propose an encrypted search scheme using bloom filters
and use soundex coding\cite{odell1918soundex} to search similar words. Kuzu et al.\cite{mehmat} carry out similarity-based encrypted search 
using locality sensitive hashing for similarity score calculation. 
In general, none of these works attempt to reduce the communication cost of 
returning results to the client.


\textbf{Using Homomorphic Encryption.}
Homomorphic encryption
allows computations to be carried out on ciphertext, thus generating an 
encrypted result, which when decrypted, matches the result of operations performed 
on the plaintext. An example of homomorphic encryption is the Pascal Paillier 
cryptosystem~\cite{pascal}, which provides two useful properties: 
(i) the product of two ciphertexts will decrypt to the sum of their corresponding plaintexts
and (ii) a ciphertext raised to a constant $k$ will decrypt to the product of the 
corresponding plaintext and the constant.

Pervez et al.~\cite{zeehan} propose an encrypted data search scheme using an inverted index and homomorphic encryption~\cite{craig}.
They use homomorphic encryption to provide end-to-end privacy. Only
authorized users can execute queries using their personal proxy re-encryption keys in
order to manipulate the index, so a lot of computation is done due to index
transformations. They use a trusted third party to rank search results and model queries.
While this approach avoids using trapdoors, it still supports only
exact keyword matching and has high communication cost.
Finally, CryptDB~\cite{popa2011cryptdb} and MONOMI~\cite{tu2013processing} improve the performance of searching over encrypted data 
by employing customized forms of encryption for specific kinds of data.
However, in doing so, they are vulnerable to several kinds of information 
leakage but with low probability.
